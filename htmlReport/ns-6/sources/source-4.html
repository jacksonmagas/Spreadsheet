


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SpreadsheetSliceView</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.example.huskysheet.client.Utils</a>
</div>

<h1>Coverage Summary for Class: SpreadsheetSliceView (com.example.huskysheet.client.Utils)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SpreadsheetSliceView</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/65)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SpreadsheetSliceView$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpreadsheetSliceView$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SpreadsheetSliceView$Direction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/91)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.example.huskysheet.client.Utils;
&nbsp;
&nbsp;import com.example.huskysheet.client.Model.ICell;
&nbsp;import com.example.huskysheet.client.Model.ISpreadsheet;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.ListIterator;
&nbsp;import java.util.NoSuchElementException;
&nbsp;
&nbsp;/**
&nbsp; * Class providing a read only view of a row or column of an ISpreadsheet as a list.
&nbsp; */
&nbsp;public class SpreadsheetSliceView implements List&lt;ICell&gt; {
&nbsp;    ISpreadsheet spreadsheet;
&nbsp;    Direction direction;
&nbsp;
&nbsp;    public int getRowColNumber() {
<b class="nc">&nbsp;        return rowColNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setRowColNumber(int rowColNumber) {
<b class="nc">&nbsp;        this.rowColNumber = rowColNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    int rowColNumber;
&nbsp;
<b class="nc">&nbsp;    public enum Direction {</b>
<b class="nc">&nbsp;        row, column</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public SpreadsheetSliceView(ISpreadsheet spreadsheet, Direction direction, int rowColNumber) {</b>
<b class="nc">&nbsp;        this.spreadsheet = spreadsheet;</b>
<b class="nc">&nbsp;        this.direction = direction;</b>
<b class="nc">&nbsp;        this.rowColNumber = rowColNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of cells in each row/col
&nbsp;     *
&nbsp;     * @return the number of elements in this list
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int size() {
<b class="nc">&nbsp;        return direction == Direction.row ? spreadsheet.numColumns() : spreadsheet.numRows();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this list contains no elements.
&nbsp;     *
&nbsp;     * @return {@code true} if this list contains no elements
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        return spreadsheet.numRows() == 0 &amp;&amp; spreadsheet.numColumns() == 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this list contains the specified element. More formally, returns
&nbsp;     * {@code true} if and only if this list contains at least one element {@code e} such that
&nbsp;     * {@code Objects.equals(o, e)}.
&nbsp;     *
&nbsp;     * @param o element whose presence in this list is to be tested
&nbsp;     * @return {@code true} if this list contains the specified element
&nbsp;     * @throws ClassCastException   if the type of the specified element is incompatible with this
&nbsp;     *                              list (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException if the specified element is null and this list does not permit
&nbsp;     *                              null elements (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean contains(Object o) {
<b class="nc">&nbsp;        if (o == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (o instanceof ICell cell) {</b>
<b class="nc">&nbsp;            return spreadsheet.getCell(cell.getCoordinate()).equals(cell);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new ClassCastException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an iterator over the elements in this list in proper sequence.
&nbsp;     *
&nbsp;     * @return an iterator over the elements in this list in proper sequence
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Iterator&lt;ICell&gt; iterator() {
<b class="nc">&nbsp;        return new Iterator&lt;&gt;() {</b>
<b class="nc">&nbsp;            private int idx = 0;</b>
&nbsp;            /**
&nbsp;             * Returns {@code true} if the iteration has more elements. (In other words,
&nbsp;             * returns {@code true} if {@link #next} would return an element rather than
&nbsp;             * throwing an exception.)
&nbsp;             *
&nbsp;             * @return {@code true} if the iteration has more elements
&nbsp;             */
&nbsp;            @Override
&nbsp;            public boolean hasNext() {
<b class="nc">&nbsp;                return idx &lt; (direction == Direction.row ? spreadsheet.numColumns() : spreadsheet.numRows());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the next element in the iteration.
&nbsp;             *
&nbsp;             * @return the next element in the iteration
&nbsp;             * @throws NoSuchElementException if the iteration has no more elements
&nbsp;             */
&nbsp;            @Override
&nbsp;            public ICell next() {
<b class="nc">&nbsp;                if (!hasNext()) {</b>
<b class="nc">&nbsp;                    throw new NoSuchElementException();</b>
&nbsp;                }
&nbsp;                Coordinate nextCoordinate;
<b class="nc">&nbsp;                if (direction == Direction.row) {</b>
<b class="nc">&nbsp;                    nextCoordinate = new Coordinate(rowColNumber, idx++);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    nextCoordinate = new Coordinate(idx++, rowColNumber);</b>
&nbsp;                }
<b class="nc">&nbsp;                return spreadsheet.getCell(nextCoordinate);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an array containing all of the elements in this list in proper sequence (from first
&nbsp;     * to last element).
&nbsp;     *
&nbsp;     * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
&nbsp;     * maintained by this list.  (In other words, this method must allocate a new array even if this
&nbsp;     * list is backed by an array). The caller is thus free to modify the returned array.
&nbsp;     *
&nbsp;     * &lt;p&gt;This method acts as bridge between array-based and collection-based
&nbsp;     * APIs.
&nbsp;     *
&nbsp;     * @return an array containing all of the elements in this list in proper sequence
&nbsp;     * @see Arrays#asList(Object[])
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ICell[] toArray() {
<b class="nc">&nbsp;        ICell[] array = new ICell[size()];</b>
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        for (ICell cell : this) {</b>
<b class="nc">&nbsp;            array[i] = cell;</b>
&nbsp;        }
<b class="nc">&nbsp;        return array;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an array containing all of the elements in this list in proper sequence (from first
&nbsp;     * to last element); the runtime type of the returned array is that of the specified array.  If
&nbsp;     * the list fits in the specified array, it is returned therein.  Otherwise, a new array is
&nbsp;     * allocated with the runtime type of the specified array and the size of this list.
&nbsp;     *
&nbsp;     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,
&nbsp;     * the array has more elements than the list), the element in the array immediately following
&nbsp;     * the end of the list is set to {@code null}. (This is useful in determining the length of the
&nbsp;     * list
&nbsp;     * &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain any null elements.)
&nbsp;     *
&nbsp;     * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
&nbsp;     * array-based and collection-based APIs.  Further, this method allows precise control over the
&nbsp;     * runtime type of the output array, and may, under certain circumstances, be used to save
&nbsp;     * allocation costs.
&nbsp;     *
&nbsp;     * &lt;p&gt;Suppose {@code x} is a list known to contain only strings.
&nbsp;     * The following code can be used to dump the list into a newly allocated array of
&nbsp;     * {@code String}:
&nbsp;     *
&nbsp;     * &lt;pre&gt;{@code
&nbsp;     *     String[] y = x.toArray(new String[0]);
&nbsp;     * }&lt;/pre&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that {@code toArray(new Object[0])} is identical in function to {@code toArray()}.
&nbsp;     *
&nbsp;     * @param a the array into which the elements of this list are to be stored, if it is big
&nbsp;     *          enough; otherwise, a new array of the same runtime type is allocated for this
&nbsp;     *          purpose.
&nbsp;     * @return an array containing the elements of this list
&nbsp;     * @throws ArrayStoreException  if the runtime type of the specified array is not a supertype of
&nbsp;     *                              the runtime type of every element in this list
&nbsp;     * @throws NullPointerException if the specified array is null
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    @Override
&nbsp;    public &lt;T&gt; T[] toArray(T[] a) {
<b class="nc">&nbsp;        if (!(a.getClass().getComponentType().isAssignableFrom(ICell[].class))) {</b>
<b class="nc">&nbsp;            throw new ArrayStoreException();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (a.length &lt; size()) {</b>
&nbsp;            ICell[] cell;
<b class="nc">&nbsp;            cell = toArray();</b>
<b class="nc">&nbsp;            return (T[]) cell;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            int idx = 0;</b>
<b class="nc">&nbsp;            for (ICell cell : this) {</b>
<b class="nc">&nbsp;                a[idx] = (T) cell;</b>
&nbsp;            }
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the specified element to the end of this list (optional operation).
&nbsp;     *
&nbsp;     * &lt;p&gt;Lists that support this operation may place limitations on what
&nbsp;     * elements may be added to this list.  In particular, some lists will refuse to add null
&nbsp;     * elements, and others will impose restrictions on the type of elements that may be added.
&nbsp;     * List classes should clearly specify in their documentation any restrictions on what elements
&nbsp;     * may be added.
&nbsp;     *
&nbsp;     * @param cell element to be appended to this list
&nbsp;     * @return {@code true} (as specified by {@link Collection#add})
&nbsp;     * @throws UnsupportedOperationException if the {@code add} operation is not supported by this
&nbsp;     *                                       list
&nbsp;     * @throws ClassCastException            if the class of the specified element prevents it from
&nbsp;     *                                       being added to this list
&nbsp;     * @throws NullPointerException          if the specified element is null and this list does not
&nbsp;     *                                       permit null elements
&nbsp;     * @throws IllegalArgumentException      if some property of this element prevents it from being
&nbsp;     *                                       added to this list
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean add(ICell cell) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the first occurrence of the specified element from this list, if it is present
&nbsp;     * (optional operation).  If this list does not contain the element, it is unchanged.  More
&nbsp;     * formally, removes the element with the lowest index {@code i} such that
&nbsp;     * {@code Objects.equals(o, get(i))} (if such an element exists).  Returns {@code true} if this
&nbsp;     * list contained the specified element (or equivalently, if this list changed as a result of
&nbsp;     * the call).
&nbsp;     *
&nbsp;     * @param o element to be removed from this list, if present
&nbsp;     * @return {@code true} if this list contained the specified element
&nbsp;     * @throws ClassCastException            if the type of the specified element is incompatible
&nbsp;     *                                       with this list (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException          if the specified element is null and this list does not
&nbsp;     *                                       permit null elements (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws UnsupportedOperationException if the {@code remove} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean remove(Object o) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this list contains all of the elements of the specified collection.
&nbsp;     *
&nbsp;     * @param c collection to be checked for containment in this list
&nbsp;     * @return {@code true} if this list contains all of the elements of the specified collection
&nbsp;     * @throws ClassCastException   if the types of one or more elements in the specified collection
&nbsp;     *                              are incompatible with this list (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException if the specified collection contains one or more null elements
&nbsp;     *                              and this list does not permit null elements (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), or
&nbsp;     *                              if the specified collection is null
&nbsp;     * @see #contains(Object)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean containsAll(Collection&lt;?&gt; c) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Appends all of the elements in the specified collection to the end of this list, in the order
&nbsp;     * that they are returned by the specified collection&#39;s iterator (optional operation).  The
&nbsp;     * behavior of this operation is undefined if the specified collection is modified while the
&nbsp;     * operation is in progress.  (Note that this will occur if the specified collection is this
&nbsp;     * list, and it&#39;s nonempty.)
&nbsp;     *
&nbsp;     * @param c collection containing elements to be added to this list
&nbsp;     * @return {@code true} if this list changed as a result of the call
&nbsp;     * @throws UnsupportedOperationException if the {@code addAll} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     * @throws ClassCastException            if the class of an element of the specified collection
&nbsp;     *                                       prevents it from being added to this list
&nbsp;     * @throws NullPointerException          if the specified collection contains one or more null
&nbsp;     *                                       elements and this list does not permit null elements,
&nbsp;     *                                       or if the specified collection is null
&nbsp;     * @throws IllegalArgumentException      if some property of an element of the specified
&nbsp;     *                                       collection prevents it from being added to this list
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean addAll(Collection&lt;? extends ICell&gt; c) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts all of the elements in the specified collection into this list at the specified
&nbsp;     * position (optional operation).  Shifts the element currently at that position (if any) and
&nbsp;     * any subsequent elements to the right (increases their indices).  The new elements will appear
&nbsp;     * in this list in the order that they are returned by the specified collection&#39;s iterator.  The
&nbsp;     * behavior of this operation is undefined if the specified collection is modified while the
&nbsp;     * operation is in progress.  (Note that this will occur if the specified collection is this
&nbsp;     * list, and it&#39;s nonempty.)
&nbsp;     *
&nbsp;     * @param index index at which to insert the first element from the specified collection
&nbsp;     * @param c     collection containing elements to be added to this list
&nbsp;     * @return {@code true} if this list changed as a result of the call
&nbsp;     * @throws UnsupportedOperationException if the {@code addAll} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     * @throws ClassCastException            if the class of an element of the specified collection
&nbsp;     *                                       prevents it from being added to this list
&nbsp;     * @throws NullPointerException          if the specified collection contains one or more null
&nbsp;     *                                       elements and this list does not permit null elements,
&nbsp;     *                                       or if the specified collection is null
&nbsp;     * @throws IllegalArgumentException      if some property of an element of the specified
&nbsp;     *                                       collection prevents it from being added to this list
&nbsp;     * @throws IndexOutOfBoundsException     if the index is out of range
&nbsp;     *                                       ({@code index &lt; 0 || index &gt; size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean addAll(int index, Collection&lt;? extends ICell&gt; c) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Removes from this list all of its elements that are contained in the specified collection
&nbsp;     * (optional operation).
&nbsp;     *
&nbsp;     * @param c collection containing elements to be removed from this list
&nbsp;     * @return {@code true} if this list changed as a result of the call
&nbsp;     * @throws UnsupportedOperationException if the {@code removeAll} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     * @throws ClassCastException            if the class of an element of this list is incompatible
&nbsp;     *                                       with the specified collection (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException          if this list contains a null element and the specified
&nbsp;     *                                       collection does not permit null elements (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
&nbsp;     *                                       or if the specified collection is null
&nbsp;     * @see #remove(Object)
&nbsp;     * @see #contains(Object)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean removeAll(Collection&lt;?&gt; c) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retains only the elements in this list that are contained in the specified collection
&nbsp;     * (optional operation).  In other words, removes from this list all of its elements that are
&nbsp;     * not contained in the specified collection.
&nbsp;     *
&nbsp;     * @param c collection containing elements to be retained in this list
&nbsp;     * @return {@code true} if this list changed as a result of the call
&nbsp;     * @throws UnsupportedOperationException if the {@code retainAll} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     * @throws ClassCastException            if the class of an element of this list is incompatible
&nbsp;     *                                       with the specified collection (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException          if this list contains a null element and the specified
&nbsp;     *                                       collection does not permit null elements (&lt;a
&nbsp;     *                                       href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
&nbsp;     *                                       or if the specified collection is null
&nbsp;     * @see #remove(Object)
&nbsp;     * @see #contains(Object)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean retainAll(Collection&lt;?&gt; c) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes all of the elements from this list (optional operation). The list will be empty after
&nbsp;     * this call returns.
&nbsp;     *
&nbsp;     * @throws UnsupportedOperationException if the {@code clear} operation is not supported by this
&nbsp;     *                                       list
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void clear() {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the element at the specified position in this list.
&nbsp;     *
&nbsp;     * @param index index of the element to return
&nbsp;     * @return the element at the specified position in this list
&nbsp;     * @throws IndexOutOfBoundsException if the index is out of range
&nbsp;     *                                   ({@code index &lt; 0 || index &gt;= size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ICell get(int index) {
<b class="nc">&nbsp;        return spreadsheet.getCell(direction == Direction.row ? new Coordinate(rowColNumber, index) : new Coordinate(index, rowColNumber));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Replaces the element at the specified position in this list with the specified element
&nbsp;     * (optional operation).
&nbsp;     *
&nbsp;     * @param index   index of the element to replace
&nbsp;     * @param element element to be stored at the specified position
&nbsp;     * @return the element previously at the specified position
&nbsp;     * @throws UnsupportedOperationException if the {@code set} operation is not supported by this
&nbsp;     *                                       list
&nbsp;     * @throws ClassCastException            if the class of the specified element prevents it from
&nbsp;     *                                       being added to this list
&nbsp;     * @throws NullPointerException          if the specified element is null and this list does not
&nbsp;     *                                       permit null elements
&nbsp;     * @throws IllegalArgumentException      if some property of the specified element prevents it
&nbsp;     *                                       from being added to this list
&nbsp;     * @throws IndexOutOfBoundsException     if the index is out of range
&nbsp;     *                                       ({@code index &lt; 0 || index &gt;= size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ICell set(int index, ICell element) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts the specified element at the specified position in this list (optional operation).
&nbsp;     * Shifts the element currently at that position (if any) and any subsequent elements to the
&nbsp;     * right (adds one to their indices).
&nbsp;     *
&nbsp;     * @param index   index at which the specified element is to be inserted
&nbsp;     * @param element element to be inserted
&nbsp;     * @throws UnsupportedOperationException if the {@code add} operation is not supported by this
&nbsp;     *                                       list
&nbsp;     * @throws ClassCastException            if the class of the specified element prevents it from
&nbsp;     *                                       being added to this list
&nbsp;     * @throws NullPointerException          if the specified element is null and this list does not
&nbsp;     *                                       permit null elements
&nbsp;     * @throws IllegalArgumentException      if some property of the specified element prevents it
&nbsp;     *                                       from being added to this list
&nbsp;     * @throws IndexOutOfBoundsException     if the index is out of range
&nbsp;     *                                       ({@code index &lt; 0 || index &gt; size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void add(int index, ICell element) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the element at the specified position in this list (optional operation).  Shifts any
&nbsp;     * subsequent elements to the left (subtracts one from their indices).  Returns the element that
&nbsp;     * was removed from the list.
&nbsp;     *
&nbsp;     * @param index the index of the element to be removed
&nbsp;     * @return the element previously at the specified position
&nbsp;     * @throws UnsupportedOperationException if the {@code remove} operation is not supported by
&nbsp;     *                                       this list
&nbsp;     * @throws IndexOutOfBoundsException     if the index is out of range
&nbsp;     *                                       ({@code index &lt; 0 || index &gt;= size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ICell remove(int index) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the index of the first occurrence of the specified element in this list, or -1 if
&nbsp;     * this list does not contain the element. More formally, returns the lowest index {@code i}
&nbsp;     * such that {@code Objects.equals(o, get(i))}, or -1 if there is no such index.
&nbsp;     *
&nbsp;     * @param o element to search for
&nbsp;     * @return the index of the first occurrence of the specified element in this list, or -1 if
&nbsp;     * this list does not contain the element
&nbsp;     * @throws ClassCastException   if the type of the specified element is incompatible with this
&nbsp;     *                              list (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException if the specified element is null and this list does not permit
&nbsp;     *                              null elements (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int indexOf(Object o) {
<b class="nc">&nbsp;        if (o == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (o instanceof ICell cell) {</b>
<b class="nc">&nbsp;            int idx = 0;</b>
<b class="nc">&nbsp;            for (ICell c : this) {</b>
<b class="nc">&nbsp;                if (spreadsheet.getCell(c.getCoordinate()).equals(cell)) {</b>
<b class="nc">&nbsp;                    return idx;</b>
&nbsp;                }
<b class="nc">&nbsp;                idx++;</b>
&nbsp;            }
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new ClassCastException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the index of the last occurrence of the specified element in this list, or -1 if this
&nbsp;     * list does not contain the element. More formally, returns the highest index {@code i} such
&nbsp;     * that {@code Objects.equals(o, get(i))}, or -1 if there is no such index.
&nbsp;     *
&nbsp;     * @param o element to search for
&nbsp;     * @return the index of the last occurrence of the specified element in this list, or -1 if this
&nbsp;     * list does not contain the element
&nbsp;     * @throws ClassCastException   if the type of the specified element is incompatible with this
&nbsp;     *                              list (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     * @throws NullPointerException if the specified element is null and this list does not permit
&nbsp;     *                              null elements (&lt;a
&nbsp;     *                              href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int lastIndexOf(Object o) {
<b class="nc">&nbsp;        if (o == null) {</b>
<b class="nc">&nbsp;            throw new NullPointerException();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (o instanceof ICell cell) {</b>
<b class="nc">&nbsp;            int idx = size() - 1;</b>
<b class="nc">&nbsp;            for (ICell c : this.reversed()) {</b>
<b class="nc">&nbsp;                if (spreadsheet.getCell(c.getCoordinate()).equals(cell)) {</b>
<b class="nc">&nbsp;                    return idx;</b>
&nbsp;                }
<b class="nc">&nbsp;                idx--;</b>
&nbsp;            }
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new ClassCastException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list iterator over the elements in this list (in proper sequence).
&nbsp;     *
&nbsp;     * @return a list iterator over the elements in this list (in proper sequence)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ListIterator&lt;ICell&gt; listIterator() {
<b class="nc">&nbsp;        return listIterator(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list iterator over the elements in this list (in proper sequence), starting at the
&nbsp;     * specified position in the list. The specified index indicates the first element that would be
&nbsp;     * returned by an initial call to {@link ListIterator#next next}. An initial call to
&nbsp;     * {@link ListIterator#previous previous} would return the element with the specified index
&nbsp;     * minus one.
&nbsp;     *
&nbsp;     * @param index index of the first element to be returned from the list iterator (by a call to
&nbsp;     *              {@link ListIterator#next next})
&nbsp;     * @return a list iterator over the elements in this list (in proper sequence), starting at the
&nbsp;     * specified position in the list
&nbsp;     * @throws IndexOutOfBoundsException if the index is out of range
&nbsp;     *                                   ({@code index &lt; 0 || index &gt; size()})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ListIterator&lt;ICell&gt; listIterator(int index) {
<b class="nc">&nbsp;        if (index &gt; size()) {</b>
<b class="nc">&nbsp;            throw new IndexOutOfBoundsException();</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ListIterator&lt;&gt;() {</b>
<b class="nc">&nbsp;            int position = index;</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean hasNext() {
<b class="nc">&nbsp;                return position &lt; size();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ICell next() {
<b class="nc">&nbsp;                if (!hasNext()) {</b>
<b class="nc">&nbsp;                    throw new NoSuchElementException();</b>
&nbsp;                }
<b class="nc">&nbsp;                return get(position++);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean hasPrevious() {
<b class="nc">&nbsp;                return position &gt; 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ICell previous() {
<b class="nc">&nbsp;                if (!hasPrevious()) {</b>
<b class="nc">&nbsp;                    throw new NoSuchElementException();</b>
&nbsp;                }
<b class="nc">&nbsp;                return get(--position);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int nextIndex() {
<b class="nc">&nbsp;                return position;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int previousIndex() {
<b class="nc">&nbsp;                return position - 1;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void remove() {
<b class="nc">&nbsp;                throw new UnsupportedOperationException();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void set(ICell cell) {
<b class="nc">&nbsp;                throw new UnsupportedOperationException();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void add(ICell cell) {
<b class="nc">&nbsp;                throw new UnsupportedOperationException();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a view of the portion of this list between the specified {@code fromIndex},
&nbsp;     * inclusive, and {@code toIndex}, exclusive.  (If {@code fromIndex} and {@code toIndex} are
&nbsp;     * equal, the returned list is empty.)  The returned list is backed by this list, so
&nbsp;     * non-structural changes in the returned list are reflected in this list, and vice-versa. The
&nbsp;     * returned list supports all of the optional list operations supported by this list.&lt;p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * This method eliminates the need for explicit range operations (of the sort that commonly
&nbsp;     * exist for arrays).  Any operation that expects a list can be used as a range operation by
&nbsp;     * passing a subList view instead of a whole list.  For example, the following idiom removes a
&nbsp;     * range of elements from a list:
&nbsp;     * &lt;pre&gt;{@code
&nbsp;     *      list.subList(from, to).clear();
&nbsp;     * }&lt;/pre&gt;
&nbsp;     * Similar idioms may be constructed for {@code indexOf} and {@code lastIndexOf}, and all of the
&nbsp;     * algorithms in the {@code Collections} class can be applied to a subList.&lt;p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The semantics of the list returned by this method become undefined if the backing list (i.e.,
&nbsp;     * this list) is &lt;i&gt;structurally modified&lt;/i&gt; in any way other than via the returned list.
&nbsp;     * (Structural modifications are those that change the size of this list, or otherwise perturb
&nbsp;     * it in such a fashion that iterations in progress may yield incorrect results.)
&nbsp;     *
&nbsp;     * @param fromIndex low endpoint (inclusive) of the subList
&nbsp;     * @param toIndex   high endpoint (exclusive) of the subList
&nbsp;     * @return a view of the specified range within this list
&nbsp;     * @throws IndexOutOfBoundsException for an illegal endpoint index value
&nbsp;     *                                   ({@code fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;
&nbsp;     *                                   toIndex})
&nbsp;     */
&nbsp;    @Override
&nbsp;    public List&lt;ICell&gt; subList(int fromIndex, int toIndex) {
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(this).subList(fromIndex, toIndex);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-16 09:00</div>
</div>
</body>
</html>
